#!/usr/bin/python
import matplotlib.pyplot as plt

import sys
from os import listdir
from os.path import isfile, join
import random
import math
from numpy import array

total=0.0;
true_accept=0.0;
false_accept=0.0;
true_reject=0.0;
false_reject=0.0;


regions = [];
pts = {'err':[], 'corr':[], 'actual':[],'regions':[]};




def pct(n,t):
	if(t==0):
		return "div-by-zero"
	return str(round(n/t*100.0,5))+"%";

def test_first(s,h,line):
	fields = line.split('\t');
	if("0" in fields[h.index('OUT-ID')] and 
	str(s) in fields[h.index("ID")]):
		return 1 
	else:
		return 0

def colormap(value):
	colors = [[0,0,1],[0,1,0],[1,1,0],[1,0,0],[1,0,0]];
	thresh = 1.0/(len(colors)-1);
	idx = int(value/thresh); #gives us the index.
	local_frac = (value - thresh*idx)/value;
	r = colors[idx]*local_frac + colors[idx+1]*(1-local_frac)
	
def plot_data(pts,name):
	colors=["c","m","r","b","r","y","o"]
	for i in range(0, len(pts['corr'])):
		print "Plotting Output "+str(i)
		plt.clf();
		px = pts['corr'][i]['x']
		py = pts['corr'][i]['y']
		ex = pts['err'][i]['x']
		ey = pts['err'][i]['y']
		
		minx = min(px);
		maxx = max(px);
		dx=(maxx-minx)
		maxx += dx/2;
		minx -= dx/2;
		ex = [max(minx,min(maxx,x)) for x in ex];
		
		for j in range(0,len(pts['regions'][i])):
			rmin = array(pts['regions'][i][j]['xmin'])
			rmax = array(pts['regions'][i][j]['xmax'])
			ry = array(pts['regions'][i][j]['y'])
			ra= pts['regions'][i][j]['p']
			
			plt.plot(rmin,ry,rmax,ry,"k-",lw=1,c=colors[j], alpha=0.5);
			plt.fill_betweenx((ry),(rmin),(rmax),where=rmax>=rmin,facecolor=colors[j], alpha=0.5);
			plt.fill_betweenx(ry,rmin,rmax,where=rmax<=rmin,facecolor='black');
			
			#for k in range(0,len(rx)):
			#	plt.plot(rx[k],ry[k],"k-",lw=1,c=colors[j], alpha=0.5);

	
		plt.plot(px,py,"xg",alpha=0.4);
		plt.plot(ex,ey,"^r",alpha=0.4);
		
		for j in range(0,len(pts['regions'][i])):
			cx = pts['regions'][i][j]['cx']
			cy = pts['regions'][i][j]['y']
			plt.plot(cx,cy,"k--", c=colors[j],alpha=0.2);
			
		plt.savefig(prefix+'.'+str(i)+".png");
	
	
if(len(sys.argv) < 3):
	print "logname graph-prefix task-id"
	exit(1);

 
log = sys.argv[1];
prefix = sys.argv[2];
sel_id = int(sys.argv[3]);

flog = open(log);
header = flog.readline().split('\t');
num_lines = sum(test_first(sel_id, header,line) for line in flog);

nycoords = 10000.0
nptsperx = 10000.0
YPROB = 1.0/max(float(num_lines)/nycoords,1.0);
print "Finished Computing Length, Prob Accept:",num_lines,YPROB
flog = open(log);
epts = [];
cpts = [];
t=0;
header = flog.readline().split('\t');
print header;


for line in flog:
	try:
		fields=line.split('\t')
		id = int(fields[header.index("ID")]);
		
		if(id != sel_id):
			continue;
			
		is_accept = "y" in fields[header.index("IS-ACCEPT")];
		is_corr = "y" in fields[header.index("IS-CORR")];
		out_id = int(float(fields[header.index("OUT-ID")]));
		n = int(float(fields[header.index("n-regions")]));
		
		# count
		if is_accept and is_corr:
			true_accept+=1;
		elif is_accept and not is_corr:
			false_accept+=1;
		elif not is_accept and is_corr:
			true_reject+=1;
		elif not is_accept and not is_corr:
			false_reject+=1;
		total += 1;
		
		while out_id >= len(cpts):
			cpts.append([]);
			epts.append([]);
			pts['err'].append({'x':[],'y':[]});
			pts['corr'].append({'x':[],'y':[]});
			pts['regions'].append([]);
		
		while n >= len(pts['regions'][out_id]):
			pts['regions'][out_id].append({'xmin':[],'xmax':[],'y':[],'p':[], 'cx':[], 'cy':[]})
		
		cpt=float(fields[header.index("CORR-VAL")])
		ept=float(fields[header.index("VAL")])
		#print len(cpts[out_id]),len(pts['corr'][out_id]['x'])
		if(random.random() < YPROB):
			if(abs(ept - cpt) < 1e-4):	
				cpts[out_id].append(ept);
			else:
				epts[out_id].append(ept);
		
		#randomly sample regions and consolidate points
		if(random.random() < YPROB):
			tregions=[];
			
			for i in range(0,n):
				minx = float(fields[header.index(str(i)+".min")]);
				maxx = float(fields[header.index(str(i)+".max")]);
				probx = float(fields[header.index(str(i)+".prob")]);
				cx = float(fields[header.index(str(i)+".center")]);
				if(math.isnan(probx)):
					probx = 0;
				pts['regions'][out_id][i]['xmin'].append(minx);
				pts['regions'][out_id][i]['xmax'].append(maxx);
				pts['regions'][out_id][i]['y'].append(t);
				pts['regions'][out_id][i]['p'].append(probx);
				pts['regions'][out_id][i]['cx'].append(cx);
				
			PDENS = nptsperx/(len(cpts))
			#print len(cpts),num_lines,YPROB,PDENS
			for c in cpts[out_id]:
				if(random.random() < PDENS):
					pts['corr'][out_id]['x'].append(c);
					pts['corr'][out_id]['y'].append(t);
					
			PDENS = nptsperx/(len(epts))
			for e in epts[out_id]:
				if(random.random() < PDENS):
					pts['err'][out_id]['x'].append(e);
					pts['err'][out_id]['y'].append(t);
					
			cpts[out_id]=[];
			epts[out_id]=[];
			t+=1;
			
	except ValueError:
		print "skipping.."


print "Percent True Accepts:",pct(true_accept,total)
print "Percent False Accepts:",pct(false_accept,total)
print "Percent True Rejects:",pct(true_reject,total)
print "Percent False Rejects:",pct(false_reject,total)

plot_data(pts, prefix);
#print regions[0];
