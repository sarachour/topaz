#!/usr/bin/python

import sys
import matplotlib.pyplot as plt
import numpy as npy
import os
import random
if(len(sys.argv) <= 4):
	print "usage: FILE id# output# output-idx"
	exit(1)

file = sys.argv[1];
o_id = int(sys.argv[2]);
o_o = int(sys.argv[3]);
o_oidx = int(sys.argv[4]);
label = "Task "+str(o_id)+", Input "+str(o_o)+", Index "+str(o_oidx)

def file_len(fname, id, o_o, o_oidx):
	with open(fname) as f:
		count = 0;
		for l in f:
			try:
				fields = l.split("\t");
				f_id = int(fields[0]);
				f_o = int(fields[3]);
				f_oidx = int(fields[4]);
				if(f_id == o_id and f_o == o_o and f_oidx == o_oidx):
					count+=1;
			except ValueError:
				pass;
	return count
	
def read_file(file, o_id, o_o, o_oidx):
	TRAIN = 0
	TEST_OK = 1
	TEST_BAD = 2
	CORRECT = 3
	MAX_N_ENTRIES = 10000.0;
	length = file_len(file, o_id, o_o, o_oidx);
	print "Number entries:", length
	
	prob_acc = MAX_N_ENTRIES/float(length);
	
	print "Sampling Probability:", prob_acc
		
	f = open(file,'r')
	data = {};
	data["ctrl"] = {"min":[], "max":[], "mean":[]};
	data["reexec"] = {"rrate":[], "lrate":[], "rate":[]};
	data["lr"] = {"left":[], "right":[]};
	data["out"] = {"corr":[], "det":[], "err":[]};

	for l in f:
		try:
			fields = l.split("\t");
			f_id = int(fields[0]);
			f_o = int(fields[3]);
			f_oidx = int(fields[4]);
			if(f_id == o_id and f_o == o_o and f_oidx == o_oidx and random.uniform(0,1) < prob_acc):
				f_o_val = float(fields[5]);
				f_cat = int(fields[6]);
				
				if(f_cat == TRAIN or f_cat == TEST_OK):
					f_mean = float(fields[8]);
					f_lb = float(fields[9]);
					f_rb = float(fields[16]);
					
					f_reexec_l = float(fields[12]);
					f_reexec_r = float(fields[19]);
					f_reexec = (f_reexec_l*0.5 + f_reexec_r*0.5)
					
					f_lfreq = float(fields[10]);
					f_rfreq = float(fields[17]);
					data["ctrl"]["min"].append(f_mean-f_lb);
					data["ctrl"]["max"].append(f_mean+f_rb);
					data["ctrl"]["mean"].append(f_mean);
					
					data["reexec"]["rrate"].append(f_reexec_r);
					data["reexec"]["lrate"].append(f_reexec_l);
					data["reexec"]["rate"].append(f_reexec);
					
					data["lr"]["left"].append(f_lfreq);
					data["lr"]["right"].append(f_rfreq);
				
					
				if(f_cat == TRAIN): 
					data["out"]["det"].append(f_o_val);
				elif(f_cat == TEST_OK):
					data["out"]["det"].append(f_o_val);
				elif(f_cat == CORRECT):
					data["out"]["corr"].append(f_o_val);
					f_oold = float(fields[7]);
					if(abs(f_o_val - f_oold) > 1e-10):
						data["out"]["err"].append(f_oold);
			
		except ValueError:
			print "skipping line."
	return data;

def draw_control(plt, data):
	t_min = range(0, len(data["ctrl"]["min"]));
	t_mean = range(0, len(data["ctrl"]["mean"]));
	t_max = range(0, len(data["ctrl"]["max"]));
	plt.set_title("Detector Bounds over Time for "+label);
	plt.plot(t_min, data["ctrl"]["min"], 'r', label="left bound");
	plt.plot(t_max, data["ctrl"]["max"], 'g', label="right bound");
	plt.plot(t_mean, data["ctrl"]["mean"], 'b', label="mean");
	plt.set_xlabel("time");
	plt.set_ylabel("output value");
	
	box = plt.get_position();
	plt.set_position([box.x0, box.y0, box.width*0.8, box.height])
	plt.legend(loc="center left", bbox_to_anchor=(1, 0.5));

def draw_reexec(plt, data):
	t_left = range(0, len(data["reexec"]["lrate"]));
	t_avg = range(0, len(data["reexec"]["rate"]));
	t_right = range(0, len(data["reexec"]["rrate"]));
	#plt.set_yscale('log');
	plt.plot(t_left, data["reexec"]["lrate"], "r", label="left");
	plt.plot(t_right, data["reexec"]["rrate"], 'g', label="right");
	plt.plot(t_avg, data["reexec"]["rate"], 'b', label="total");
	#print data["reexec"]["rate"]
	plt.set_title("Re-Execution Rates for "+label);
	plt.set_xlabel("time");
	plt.set_ylabel("reexecution rate");
	
	box = plt.get_position();
	plt.set_position([box.x0, box.y0, box.width*0.8, box.height])
	plt.legend(loc="center left", bbox_to_anchor=(1, 0.5));

def draw_freqs(plt,data):
	t_left = range(0, len(data["lr"]["left"]));
	t_right = range(0, len(data["lr"]["right"]));
	plt.plot(t_left, data["lr"]["left"], 'r',  label="left");
	plt.plot(t_right, data["lr"]["right"], 'g', label="right");
	plt.set_title("Left/Right Bound Trigger Rates for "+label);
	plt.set_xlabel("time");
	plt.set_ylabel("frequency left/right bound is triggered");
	
	box = plt.get_position();
	plt.set_position([box.x0, box.y0, box.width*0.8, box.height])
	plt.legend(loc="center left", bbox_to_anchor=(1, 0.5));

def draw_total_dist(plt,data):
	amin = min(data["out"]["corr"]);
	amax = max(data["out"]["corr"]);
	aavg = (amax + amin)/2.0
	alen = (amax - amin)/2.0;
	dmin = aavg - alen*2;
	dmax = aavg + alen*2;
	print "det bounds:", amin, amax
	print "bounds:",dmin,dmax
	
	err = npy.clip(data["out"]["err"], dmin, dmax);
	#replace nans with the max
	corr = data["out"]["corr"];
	corr = npy.array(corr);
	
	corr[npy.isnan(corr)] = dmax;
	err[npy.isnan(err)] = dmax;
	
	err = err.tolist();
	corr = corr.tolist();
	#plt.hist(corr, 100, normed=True,histtype="step",color="g");
	plt.hist(corr+err, 200,normed=True,histtype="step",color=["g"], label=["Output+Err Distribution"]);
	

	
	box = plt.get_position();
	plt.set_position([box.x0, box.y0, box.width*0.8, box.height])
	plt.legend(loc="center left", bbox_to_anchor=(1, 0.5));
	
	plt.set_ylabel("probability");
	plt.set_title("Output Probability Distribution for "+label);
	#plt.hist(data["out"]["err"], 1000, normed=True,histtype="step",color="r");


def draw_output(plt,plt2,data):
	amin = min(data["out"]["corr"]);
	amax = max(data["out"]["corr"]);
	aavg = (amax + amin)/2.0
	alen = (amax - amin)/2.0;
	dmin = aavg - alen*2;
	dmax = aavg + alen*2;
	print "det bounds:", amin, amax
	print "bounds:",dmin,dmax
	
	err = npy.clip(data["out"]["err"], dmin, dmax);
	det = npy.clip(data["out"]["det"], dmin, dmax);
	#replace nans with the max
	corr = data["out"]["corr"];
	corr = npy.array(corr);
	print "nans:",npy.count_nonzero(npy.isnan(corr)), npy.count_nonzero(npy.isnan(det)), npy.count_nonzero(npy.isnan(err))
	corr[npy.isnan(corr)] = dmax;
	err[npy.isnan(err)] = dmax;
	det[npy.isnan(det)] = dmax;
	
	err = err.tolist();
	det = det.tolist();
	corr = corr.tolist();
	#plt.hist(corr, 100, normed=True,histtype="step",color="g");
	plt.hist([corr,det], 200,normed=True,histtype="step",color=["g",  "b"], label=["Output","Detector"]);
	
	plt2.hist([err], 200,normed=True,histtype="step",color=["r"], label=["Error"]);
	
	
	box = plt.get_position();
	plt.set_position([box.x0, box.y0, box.width*0.8, box.height])
	plt.legend(loc="center left", bbox_to_anchor=(1, 0.5));
	
	plt.set_ylabel("probability");
	plt.set_title("Output Probability Distribution for "+label);
	
	box = plt2.get_position();
	plt2.set_position([box.x0, box.y0, box.width*0.8, box.height])
	plt2.legend(loc="center left", bbox_to_anchor=(1, 0.5));
	
	plt2.set_xlabel("output value");
	plt2.set_ylabel("probability");
	#plt.hist(data["out"]["err"], 1000, normed=True,histtype="step",color="r");

def draw_bounds_output(plt, plt2, data):
	amin = min(data["out"]["corr"]);
	amax = max(data["out"]["corr"]);
	aavg = (amax + amin)/2.0
	alen = (amax - amin)/2.0;
	dmin = aavg - alen*2;
	dmax = aavg + alen*2;
	print "det bounds:", amin, amax
	print "bounds:",dmin,dmax
	
	err = npy.clip(data["out"]["err"], dmin, dmax);
	det = npy.clip(data["out"]["det"], dmin, dmax);
	#replace nans with the max
	corr = data["out"]["corr"];
	corr = npy.array(corr);
	corr[npy.isnan(corr)] = dmax;
	err[npy.isnan(err)] = dmax;
	det[npy.isnan(det)] = dmax;
	
	err = err.tolist();
	det = det.tolist();
	corr = corr.tolist();
	#plt.hist(corr, 100, normed=True,histtype="step",color="g");
	x,y,o = plt.hist([corr,det], 200,normed=True,histtype="step",color=["g",  "b"], label=["Output","Detector"]);
	
	x2,y2,o2 = plt2.hist([err], 200,normed=True,histtype="step",color=["r"], label=["Error"]);
	
	
	box = plt.get_position();
	plt.set_position([box.x0, box.y0, box.width*0.8, box.height])
	plt.legend(loc="center left", bbox_to_anchor=(1, 0.5));
	
	plt.set_ylabel("probability");
	plt.set_title("Output Probability Distribution for "+label);
	
	box = plt2.get_position();
	plt2.set_position([box.x0, box.y0, box.width*0.8, box.height])
	plt2.legend(loc="center left", bbox_to_anchor=(1, 0.5));
	
	plt2.set_xlabel("output value");
	plt2.set_ylabel("probability");
	
	dlen = len(data['ctrl']['min']);
	
	ymin,ymax=plt.get_ylim();
	factor = 1/float(dlen)*(ymax-ymin); 
	t_plt = map(lambda x: x*factor+ymin, range(0, dlen));
	
	ymin,ymax=plt2.get_ylim();
	factor = 1/float(dlen)*(ymax-ymin); 
	e_plt = map(lambda x: x*factor+ymin, range(0, dlen));
	#dlen = len(data['ctrl']['max']); t_plt_max = range(0, dlen)*(max(y)/(float(dlen)));
	#dlen = len(data['ctrl']['mean']); t_plt_avg = range(0, dlen)*(max(y)/(float(dlen)));
	
	#plot data
	cmin=(0.6,0.3,0.6,0.9);
	cmax=(0.3,0.6,0.6,0.9);
	cavg=(0.3,0.3,0.3,0.9);
	
	plt.plot(data["ctrl"]["min"],t_plt, '-', color=cmin, label="left bound");
	plt.plot(data["ctrl"]["max"],t_plt, '-', color=cmax,label="right bound");
	plt.plot(data["ctrl"]["mean"], t_plt, '-', color=cavg, label="mean");
	
	plt2.plot(data["ctrl"]["min"],e_plt, '-', color=cmin, label="left bound");
	plt2.plot(data["ctrl"]["max"],e_plt, '-', color=cmax,label="right bound");
	plt2.plot(data["ctrl"]["mean"], e_plt, '-', color=cavg, label="mean");
	
		
print "#Reading"
head, tail = os.path.split(file);
data = read_file(file, o_id, o_o, o_oidx);
print "#Plotting"
fig = plt.figure();
tag = "out_"+str(o_id)+"_"+str(o_o)+"_"+str(o_oidx);

ax = fig.add_subplot(2,1,1);
draw_control(ax, data);
ax = fig.add_subplot(2,1,2);
draw_reexec(ax,data)
fig.savefig(head+"/bounds."+tag+".png");

fig2 = plt.figure();
ax = fig2.add_subplot(1,1,1);
draw_freqs(ax,data);
fig2.savefig(head+"/freqs."+tag+".png");

fig3, (ax,ax2) = plt.subplots(2, sharex=True);
draw_output(ax, ax2, data);
fig3.savefig(head+"/dist."+tag+".png");


fig4, (ax,ax2) = plt.subplots(2, sharex=True);
draw_bounds_output(ax, ax2, data);
fig4.savefig(head+"/dist.bnd."+tag+".png");

fig5 = plt.figure();
ax = fig5.add_subplot(1,1,1);
draw_total_dist(ax, data);
fig5.savefig(head+"/dist.all."+tag+".png");

#plt.show();
