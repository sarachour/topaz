TODO: Adjust data structures to keep track of used data size for sending input_info.
TODO: input info is dynamically allocated so TASK_SIZE can be set at beginning of fxn.
/*
* don't need to keep track of task size - matches with message leq size.
*/
/*
Adopt: Jade Local Pointer Mechanism (Jade 2.2.1): 
allocate_object() allocate object, size in hashtable
global_deref(ptr) dereference pointer from hashtable
ptr_size(ptr) get size of allocated data

*/
/*
TODO: Think of how to handle redundant data transfer
event driven program - ??

*/
 
#Structures
topaz_info_t: contains all the topaz runtime information and options.
	-> num_tasks_running[NUM_MACHINES]: number of farmed out tasks to each machine.
	-> taskset_index: index of current taskset in the main thread.
	-> task_map: map tasks to task run function, input/output packing/unpacking routines.
	-> option: an integer mask that contains options available.
		-> option::DISOWN_LAGGING_TASKS : this will be a global that determines if we should disown lagging tasks.
	/*machine info*/
	-> machine_hostname: machine hostname
	-> machine_rank: machine rank
	-> total_number_machines: total number of machines
	-> machine_rel: is the machine reliable or unreliable.
	-> machine_main: is this machine the main thread machine.
	-> INTERNAL_machine_index: last machine task was allocated to.
	
task_info_t:  contains all relevent information for an input message.
	-> task id: block of code to execute.
	-> task rank: index of task.
	-> data: arguments needed for computation.

pack_info_t: contains info for packing the elemnts. /* this may be expanded depending on how tightly we pack elements*/
	-> offset: offset of data portion
	-> size: size of data portion.

task_status_t: contains the status of the collect call. The collect may have aborted early, in which case we
do not run the collected info-dependent tasks;
*/


#API_CALLS
task_info * create_task_info(int data_size);
init_topaz_info(int max_num_tasks, int options) : initialize number of tasks, options. Called in runtime.
init_task_info(task_info_t * t, int task_id, int task_rank) : initialize input task struct.
init_pack_info(pack_info_t * p); : initialize packing info.
int topaz_add_task(**) : add a task, return its index.

void task_pack_int(task_info_t * t,  pack_info * p, int val) : pack int. returns new offset
void task_pack_int_array(task_info_t * t, pack_info * p, int ** val, int len) : pack int array. returns new offset.
/*
same functions for char, float, double. 
Note: offset may not be int aligned.
*/

int unpack_int(int * t, int offset, int * sval);
int unpack_int_array(int * t, int offset, int ** sval, int * len);
/*
same functions for char, float, double. 
Note: offset may not be int aligned.
*/

start_taskset(topaz_info_t * topaz);
dispatch_task(topaz_info_t * topaz, input_info_t * task, pack_info * p);
collect_task(topaz_info_t * topaz, output_info_t * task, task_status_t * status);
tasks_left()

#SPECIAL_FUNCTIONS
topaz_main(topaz_info topaz){
...
}
